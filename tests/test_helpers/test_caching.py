"""Tests for caching helper functions."""
from datetime import timedelta
from unittest.mock import patch

import pytest
from django.core.cache import cache
from django.utils import timezone

from futurex_openedx_extensions.helpers import constants as cs
from futurex_openedx_extensions.helpers.caching import cache_dict, invalidate_cache


@pytest.fixture
def mock_cache():
    """Fixture to mock the cache get and set methods."""
    with patch.object(cache, 'get') as mock_get:
        with patch.object(cache, 'set') as mock_set:
            with patch.object(cache, 'delete') as mock_delete:
                with patch.object(timezone, 'now') as frozen_now:
                    frozen_now.return_value = timezone.now()
                    yield mock_get, mock_set, mock_delete, frozen_now.return_value


@cache_dict(timeout=77, key_generator_or_name='test_key')
def dummy_cached_func():
    """Dummy function to test the cache decorator."""
    return {'key': 'value'}


def test_cache_hit(mock_cache):  # pylint: disable=redefined-outer-name
    """Verify that the cache is hit and the result is returned."""
    mock_get, mock_set, _, _ = mock_cache
    mock_get.return_value = {'data': {'key': 'value'}}

    result = dummy_cached_func()
    assert result == {'key': 'value'}
    mock_get.assert_called_once_with('test_key')
    mock_set.assert_not_called()


def test_cache_miss(mock_cache):  # pylint: disable=redefined-outer-name
    """Verify that the cache is missed and the result is stored."""
    mock_get, mock_set, _, frozen_now = mock_cache
    mock_get.return_value = None

    result = dummy_cached_func()
    assert result == {'key': 'value'}
    mock_get.assert_called_once_with('test_key')
    mock_set.assert_called_once_with('test_key', {
        'created_datetime': frozen_now,
        'expiry_datetime': frozen_now + timedelta(seconds=77),
        'data': {'key': 'value'},
    }, 77)


def test_cache_key_callable(mock_cache):  # pylint: disable=redefined-outer-name
    """Verify that the cache key is generated by a callable."""
    mock_get, mock_set, _, frozen_now = mock_cache
    mock_get.return_value = None

    def key_gen(*args, **kwargs):
        return f'test_key_{args[0]}_{args[1]}'

    @cache_dict(timeout=88, key_generator_or_name=key_gen)
    def dummy_func(arg1, arg2):
        return {arg2: arg1}

    result = dummy_func(1, 'str')
    assert result == {'str': 1}
    mock_get.assert_called_once_with('test_key_1_str')
    mock_set.assert_called_once_with('test_key_1_str', {
        'created_datetime': frozen_now,
        'expiry_datetime': frozen_now + timedelta(seconds=77),
        'data': {'str': 1},
    }, 88)


def test_cache_key_generation_error(mock_cache, caplog):  # pylint: disable=redefined-outer-name
    """Verify that an error generating the cache key is logged."""
    mock_get, mock_set, _, _ = mock_cache

    def key_gen(*args, **kwargs):
        raise ValueError('Error generating key')

    @cache_dict(timeout=60, key_generator_or_name=key_gen)
    def dummy_func():
        return {'key': 'value'}

    result = dummy_func()
    assert result == {'key': 'value'}
    mock_get.assert_not_called()
    mock_set.assert_not_called()
    assert 'cache_dict: error generating cache key' in caplog.text


def test_cache_incorrect_result_type(mock_cache, caplog):  # pylint: disable=redefined-outer-name
    """Verify that an error is logged when the result is not a dictionary."""
    mock_get, mock_set, _, _ = mock_cache
    mock_get.return_value = None

    @cache_dict(timeout=77, key_generator_or_name='test_key')
    def dummy_func():
        return ['not', 'a', 'dict']

    result = dummy_func()
    assert result == ['not', 'a', 'dict']
    mock_get.assert_called_once_with('test_key')
    mock_set.assert_not_called()

    assert 'cache_dict: expecting dictionary result from dummy_func but got <class \'list\'>' in caplog.text


def test_cache_key_not_callable_or_string(mock_cache, caplog):  # pylint: disable=redefined-outer-name
    """Verify that an error is logged when the key generator is not callable or a string."""
    mock_get, mock_set, _, _ = mock_cache

    @cache_dict(timeout=60, key_generator_or_name=123)
    def dummy_func():
        return {'key': 'value'}

    result = dummy_func()
    assert result == {'key': 'value'}
    mock_get.assert_not_called()
    mock_set.assert_not_called()
    assert 'cache_dict: error generating cache key: key_generator_or_name must be a callable or a string' in caplog.text


@pytest.mark.parametrize('timeout', [-1, 0, None, 77.5])
def test_bad_timeout(mock_cache, caplog, timeout):  # pylint: disable=redefined-outer-name
    """Verify that an error is logged when the timeout is not a positive integer."""
    mock_get, mock_set, _, _ = mock_cache
    mock_get.return_value = None

    @cache_dict(timeout=timeout, key_generator_or_name='test_key')
    def dummy_func():
        return {'key': 'value'}

    result = dummy_func()
    assert result == {'key': 'value'}
    mock_get.assert_not_called()
    mock_set.assert_not_called()
    assert 'cache_dict: error generating cache key: unexpected timeout value. Should be an integer greater than 0' in \
           caplog.text


def test_read_from_settings(mock_cache, settings):  # pylint: disable=redefined-outer-name
    """Verify that the timeout is read from the settings when timeout is a string."""
    settings.TEST_TIMEOUT = 995
    mock_get, mock_set, _, frozen_now = mock_cache
    mock_get.return_value = None
    timeout = 'TEST_TIMEOUT'

    @cache_dict(timeout=timeout, key_generator_or_name='test_key')
    def dummy_func():
        return {'key': 'value'}

    result = dummy_func()
    expected_cache_content = {
        'created_datetime': frozen_now,
        'expiry_datetime': frozen_now + timedelta(seconds=995),
        'data': {'key': 'value'},
    }
    assert result == expected_cache_content['data']
    mock_get.assert_called_once()
    mock_set.assert_called_once_with('test_key', expected_cache_content, 995)

    settings.TEST_TIMEOUT = 123
    mock_get.reset_mock()
    mock_get.return_value = None
    mock_set.reset_mock()
    result = dummy_func()
    assert result == expected_cache_content['data']
    mock_get.assert_called_once()
    mock_set.assert_called_once_with('test_key', expected_cache_content, 123)


def test_read_from_settings_non_existing(mock_cache, caplog):  # pylint: disable=redefined-outer-name
    """Verify that an error is logged when the timeout is not a positive integer."""
    mock_get, mock_set, _, _ = mock_cache
    mock_get.return_value = None

    @cache_dict(timeout='NOT_EXIST_SETTING', key_generator_or_name='test_key')
    def dummy_func():
        return {'key': 'value'}

    result = dummy_func()
    assert result == {'key': 'value'}
    mock_get.assert_not_called()
    mock_set.assert_not_called()
    assert 'cache_dict: error generating cache key: timeout setting (NOT_EXIST_SETTING) not found' in caplog.text


def test_invalidate_single_cache_valid(mock_cache):  # pylint: disable=redefined-outer-name
    """Test invalidating a single valid cache."""
    _, _, mock_delete, _ = mock_cache
    valid_cache_name = cs.CACHE_NAME_ALL_TENANTS_INFO
    invalidate_cache(valid_cache_name)
    mock_delete.assert_called_once_with(valid_cache_name)


def test_invalidate_all_caches(mock_cache):  # pylint: disable=redefined-outer-name
    """Test invalidating all predefined caches."""
    _, _, mock_delete, _ = mock_cache
    all_cache_names = [
        cs.CACHE_NAME_ALL_COURSE_ORG_FILTER_LIST,
        cs.CACHE_NAME_ALL_TENANTS_INFO,
        cs.CACHE_NAME_ALL_VIEW_ROLES,
        cs.CACHE_NAME_ORG_TO_TENANT_MAP,
    ]
    invalidate_cache()
    for name in all_cache_names:
        mock_delete.assert_any_call(name)
    assert mock_delete.call_count == len(all_cache_names)
